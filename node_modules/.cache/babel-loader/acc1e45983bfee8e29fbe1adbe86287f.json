{"ast":null,"code":"var _jsxFileName = \"/home/mihkel/Projects_Folder/Iseseisev_t\\xF6\\xF6-02.03.2022/src/core/inject.tsx\",\n    _s2 = $RefreshSig$();\n\n/**\r\n * This module provides a system for dependendency injection of hooks (and components, if you really want to).\r\n *\r\n * This is achieved by three parts:\r\n * 1. Wrap the hook definition inside `injectableHook()` -- this magically replaces the hook with mocked implementation.\r\n *    (alternatively one can call `useInject(hook)` for substitution).\r\n * 2. `const hookMock = defineMock(hook, mockFunc)` defines the pairing of original hook and a replacement one.\r\n * 3. `<Inject use={hook}>` uses the information from (2) and applies it to callers that use (1).\r\n */\nimport React, { createContext, useContext } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst injectDefault = new Map();\nconst InjectContext = /*#__PURE__*/createContext(injectDefault);\n\n/**\r\n * Returns a wrapper of a hook that calls `useInject()` on *itself* -- explicit call to `useInject()` is not needed.\r\n *\r\n * https://stackoverflow.com/a/41853194/177663  - add properties to functions type-safely\r\n */\nexport const injectableHook = hook => {\n  var _s = $RefreshSig$();\n\n  // Define a wrapper for 'hook'\n  // I tried doing this type-safely but failed -- it would break type arguments of useEnhancedTable<*>\n  // (see https://stackoverflow.com/a/54946767/177663)\n  const useWrapper = function () {\n    _s();\n\n    return useInject(hook).apply(this, arguments);\n  };\n\n  _s(useWrapper, \"exBxdT63oDmyHSoc8fylWpetXMw=\", false, function () {\n    return [useInject];\n  });\n\n  return Object.assign(useWrapper, {\n    originalHook: hook\n  });\n};\n/**\r\n * Use in components that want to support dependency injection. Returns the implementation provided by the closest\r\n * parent <Inject> component. If an implementation was not provided, returns the original function unchanged.\r\n *\r\n * Code without injection:\r\n *   const {dataCallback} = useData(args);\r\n * Code after:\r\n *   const {dataCallback} = useInject(useData)(args);\r\n */\n\nexport const useInject = original => {\n  _s2();\n\n  const injections = useContext(InjectContext);\n\n  if (injections.has(original)) {\n    // This cast is type-safe, because `original` and `mock` were required to have the same type in `defineMock()`.\n    // Type-safety not trivial to achieve with native TS: https://stackoverflow.com/a/51573704/177663\n    return injections.get(original);\n  }\n\n  return original;\n};\n/**\r\n * Define a mock for a function.\r\n *\r\n * Original hook:\r\n *   const useDataService = () => 'returned by original hook';\r\n * Mock:\r\n *   const useDataMock = defineMock(useDataService, () => 'fake data');\r\n *\r\n * This function ensures that the original and replacement function have the same type.\r\n */\n\n_s2(useInject, \"rWq7FPRY59J5mRCbHQlrX2RlS6c=\");\n\nexport const defineMock = (hook, mock) => {\n  // If hook was defined with `injectableHook()`, we un-wrap the wrapper.\n  const original = 'originalHook' in hook ? hook.originalHook : hook;\n  return {\n    original,\n    mock\n  };\n};\n\n/**\r\n * Sets injection context for `useInject`.\r\n *\r\n * Example:\r\n *   <Inject use={useDataMock}>\r\n *     <UsesBlaHook />\r\n *   </Inject>\r\n *\r\n * `defineMock()` can also be used inline:\r\n *   <Inject use={defineMock(useDataService, () => 'fake data')}>\r\n */\nexport const Inject = _ref => {\n  let {\n    use,\n    children\n  } = _ref;\n  // In the future we may want to merge this with upper InjectContext?\n  let map;\n\n  if (Array.isArray(use)) {\n    map = new Map(use.map(mock => [mock.original, mock.mock]));\n  } else {\n    map = new Map([[use.original, use.mock]]);\n  }\n\n  return /*#__PURE__*/_jsxDEV(InjectContext.Provider, {\n    value: map,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 98,\n    columnNumber: 10\n  }, this);\n};\n_c = Inject;\n\nvar _c;\n\n$RefreshReg$(_c, \"Inject\");","map":{"version":3,"sources":["/home/mihkel/Projects_Folder/Iseseisev_töö-02.03.2022/src/core/inject.tsx"],"names":["React","createContext","useContext","injectDefault","Map","InjectContext","injectableHook","hook","useWrapper","useInject","apply","arguments","Object","assign","originalHook","original","injections","has","get","defineMock","mock","Inject","use","children","map","Array","isArray"],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,KAAP,IAAeC,aAAf,EAA8BC,UAA9B,QAA+C,OAA/C;;AAQA,MAAMC,aAAyB,GAAG,IAAIC,GAAJ,EAAlC;AAEA,MAAMC,aAAa,gBAAGJ,aAAa,CAACE,aAAD,CAAnC;;AAIA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMG,cAAc,GAAwBC,IAArB,IAAgD;AAAA;;AAC5E;AACA;AACA;AACA,QAAMC,UAAU,GAAI,YAAqB;AAAA;;AACvC,WAAOC,SAAS,CAACF,IAAD,CAAT,CAAgBG,KAAhB,CAAsB,IAAtB,EAA4BC,SAA5B,CAAP;AACD,GAFD;;AAJ4E,KAItEH,UAJsE;AAAA,YAKnEC,SALmE;AAAA;;AAO5E,SAAOG,MAAM,CAACC,MAAP,CAAcL,UAAd,EAA0B;AAACM,IAAAA,YAAY,EAAEP;AAAf,GAA1B,CAAP;AACD,CARM;AAUP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAME,SAAS,GAAwBM,QAArB,IAAwC;AAAA;;AAC/D,QAAMC,UAAU,GAAGd,UAAU,CAACG,aAAD,CAA7B;;AACA,MAAIW,UAAU,CAACC,GAAX,CAAeF,QAAf,CAAJ,EAA8B;AAC5B;AACA;AACA,WAAOC,UAAU,CAACE,GAAX,CAAeH,QAAf,CAAP;AACD;;AACD,SAAOA,QAAP;AACD,CARM;AAUP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAnBaN,S;;AAoBb,OAAO,MAAMU,UAAU,GAAG,CAAqBZ,IAArB,EAA8Ca,IAA9C,KAAuE;AAC/F;AACA,QAAML,QAAQ,GAAG,kBAAkBR,IAAlB,GAAyBA,IAAI,CAACO,YAA9B,GAA6CP,IAA9D;AACA,SAAO;AAACQ,IAAAA,QAAD;AAAWK,IAAAA;AAAX,GAAP;AACD,CAJM;;AAUP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,MAA6B,GAAG,QAAqB;AAAA,MAApB;AAACC,IAAAA,GAAD;AAAMC,IAAAA;AAAN,GAAoB;AAChE;AACA,MAAIC,GAAJ;;AACA,MAAIC,KAAK,CAACC,OAAN,CAAcJ,GAAd,CAAJ,EAAwB;AACtBE,IAAAA,GAAG,GAAG,IAAIpB,GAAJ,CAAQkB,GAAG,CAACE,GAAJ,CAAQJ,IAAI,IAAI,CAACA,IAAI,CAACL,QAAN,EAAgBK,IAAI,CAACA,IAArB,CAAhB,CAAR,CAAN;AACD,GAFD,MAEO;AACLI,IAAAA,GAAG,GAAG,IAAIpB,GAAJ,CAAQ,CAAC,CAACkB,GAAG,CAACP,QAAL,EAAeO,GAAG,CAACF,IAAnB,CAAD,CAAR,CAAN;AACD;;AAED,sBAAO,QAAC,aAAD,CAAe,QAAf;AAAwB,IAAA,KAAK,EAAEI,GAA/B;AAAA,cAAqCD;AAArC;AAAA;AAAA;AAAA;AAAA,UAAP;AACD,CAVM;KAAMF,M","sourcesContent":["/**\r\n * This module provides a system for dependendency injection of hooks (and components, if you really want to).\r\n *\r\n * This is achieved by three parts:\r\n * 1. Wrap the hook definition inside `injectableHook()` -- this magically replaces the hook with mocked implementation.\r\n *    (alternatively one can call `useInject(hook)` for substitution).\r\n * 2. `const hookMock = defineMock(hook, mockFunc)` defines the pairing of original hook and a replacement one.\r\n * 3. `<Inject use={hook}>` uses the information from (2) and applies it to callers that use (1).\r\n */\r\nimport React, {createContext, useContext} from 'react';\r\n\r\ntype InjectData = Map<Function, Function>;\r\nexport type MockData<T extends Function> = {\r\n  original: T;\r\n  mock: T;\r\n};\r\n\r\nconst injectDefault: InjectData = new Map();\r\n\r\nconst InjectContext = createContext(injectDefault);\r\n\r\ntype Injectable<T extends Function> = T & {originalHook: T};\r\n\r\n/**\r\n * Returns a wrapper of a hook that calls `useInject()` on *itself* -- explicit call to `useInject()` is not needed.\r\n *\r\n * https://stackoverflow.com/a/41853194/177663  - add properties to functions type-safely\r\n */\r\nexport const injectableHook = <F extends Function>(hook: F): Injectable<F> => {\r\n  // Define a wrapper for 'hook'\r\n  // I tried doing this type-safely but failed -- it would break type arguments of useEnhancedTable<*>\r\n  // (see https://stackoverflow.com/a/54946767/177663)\r\n  const useWrapper = (function (this: any) {\r\n    return useInject(hook).apply(this, arguments);\r\n  } as unknown) as F;\r\n  return Object.assign(useWrapper, {originalHook: hook});\r\n};\r\n\r\n/**\r\n * Use in components that want to support dependency injection. Returns the implementation provided by the closest\r\n * parent <Inject> component. If an implementation was not provided, returns the original function unchanged.\r\n *\r\n * Code without injection:\r\n *   const {dataCallback} = useData(args);\r\n * Code after:\r\n *   const {dataCallback} = useInject(useData)(args);\r\n */\r\nexport const useInject = <T extends Function>(original: T): T => {\r\n  const injections = useContext(InjectContext);\r\n  if (injections.has(original)) {\r\n    // This cast is type-safe, because `original` and `mock` were required to have the same type in `defineMock()`.\r\n    // Type-safety not trivial to achieve with native TS: https://stackoverflow.com/a/51573704/177663\r\n    return injections.get(original) as T;\r\n  }\r\n  return original;\r\n};\r\n\r\n/**\r\n * Define a mock for a function.\r\n *\r\n * Original hook:\r\n *   const useDataService = () => 'returned by original hook';\r\n * Mock:\r\n *   const useDataMock = defineMock(useDataService, () => 'fake data');\r\n *\r\n * This function ensures that the original and replacement function have the same type.\r\n */\r\nexport const defineMock = <T extends Function>(hook: T | Injectable<T>, mock: T): MockData<T> => {\r\n  // If hook was defined with `injectableHook()`, we un-wrap the wrapper.\r\n  const original = 'originalHook' in hook ? hook.originalHook : hook;\r\n  return {original, mock};\r\n};\r\n\r\ntype InjectProps = {\r\n  use: MockData<any> | MockData<any>[];\r\n};\r\n\r\n/**\r\n * Sets injection context for `useInject`.\r\n *\r\n * Example:\r\n *   <Inject use={useDataMock}>\r\n *     <UsesBlaHook />\r\n *   </Inject>\r\n *\r\n * `defineMock()` can also be used inline:\r\n *   <Inject use={defineMock(useDataService, () => 'fake data')}>\r\n */\r\nexport const Inject: React.FC<InjectProps> = ({use, children}) => {\r\n  // In the future we may want to merge this with upper InjectContext?\r\n  let map: InjectData;\r\n  if (Array.isArray(use)) {\r\n    map = new Map(use.map(mock => [mock.original, mock.mock]));\r\n  } else {\r\n    map = new Map([[use.original, use.mock]]);\r\n  }\r\n\r\n  return <InjectContext.Provider value={map}>{children}</InjectContext.Provider>;\r\n};\r\n"]},"metadata":{},"sourceType":"module"}